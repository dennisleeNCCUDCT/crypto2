{"ast":null,"code":"\"use strict\";\n\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexDataLength, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nlet _curve = null;\n\nfunction getCurve() {\n  if (!_curve) {\n    _curve = new EC(\"secp256k1\");\n  }\n\n  return _curve;\n}\n\nexport class SigningKey {\n  constructor(privateKey) {\n    defineReadOnly(this, \"curve\", \"secp256k1\");\n    defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n\n    if (hexDataLength(this.privateKey) !== 32) {\n      logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n    }\n\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n    defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n    defineReadOnly(this, \"_isSigningKey\", true);\n  }\n\n  _addPoint(other) {\n    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n    const p1 = getCurve().keyFromPublic(arrayify(other));\n    return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n  }\n\n  signDigest(digest) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    const digestBytes = arrayify(digest);\n\n    if (digestBytes.length !== 32) {\n      logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n    }\n\n    const signature = keyPair.sign(digestBytes, {\n      canonical: true\n    });\n    return splitSignature({\n      recoveryParam: signature.recoveryParam,\n      r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n      s: hexZeroPad(\"0x\" + signature.s.toString(16), 32)\n    });\n  }\n\n  computeSharedSecret(otherKey) {\n    const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n    return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n  }\n\n  static isSigningKey(value) {\n    return !!(value && value._isSigningKey);\n  }\n\n}\nexport function recoverPublicKey(digest, signature) {\n  const sig = splitSignature(signature);\n  const rs = {\n    r: arrayify(sig.r),\n    s: arrayify(sig.s)\n  };\n  return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n  const bytes = arrayify(key);\n\n  if (bytes.length === 32) {\n    const signingKey = new SigningKey(bytes);\n\n    if (compressed) {\n      return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n    }\n\n    return signingKey.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return hexlify(bytes);\n    }\n\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return hexlify(bytes);\n    }\n\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n  }\n\n  return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}","map":{"version":3,"mappings":"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","names":["EC","arrayify","hexDataLength","hexlify","hexZeroPad","splitSignature","defineReadOnly","Logger","version","logger","_curve","getCurve","SigningKey","constructor","privateKey","throwArgumentError","keyPair","keyFromPrivate","getPublic","_addPoint","other","p0","keyFromPublic","publicKey","p1","pub","add","encodeCompressed","signDigest","digest","digestBytes","length","signature","sign","canonical","recoveryParam","r","toString","s","computeSharedSecret","otherKey","otherKeyPair","computePublicKey","derive","isSigningKey","value","_isSigningKey","recoverPublicKey","sig","rs","recoverPubKey","encode","key","compressed","bytes","signingKey"],"sources":["/Users/lipeichen/Downloads/Hardhat_ReactJS_Tutorial-main/node_modules/@ethersproject/signing-key/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n"]},"metadata":{},"sourceType":"module"}